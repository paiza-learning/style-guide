# c++ 模範解答コーディングルール

## 基準

- 強制
- 推奨
- 条件付推奨
- 許容
- 避ける
- してはいけない

基本的には STL/boost を意識して欲しい

## ルール

### `using namespace std;` は書く

絶対使うし毎回 std 書くのはかえって読みにくいです。

### マクロを避ける

`REP` マクロなどを競技プログラミングではよく見かけますが、paiza ラーニングの模範解答欄にパーソナライズドされがちなものが載ってしまうと問題かと思います。

定数は `constexpr` 等で定義できることかと思います。

### グローバル変数は避ける

`constexpr` とかは置いてあって良いです。
クラス等にするほうが見通しがよいかもしれません.

### 変数は必要な箇所で宣言する

c ライクなスタイルで関数の頭で全ての変数を宣言している場合がありますが、c++ ではそのような配慮が特に必要ないこと、また、変数の初期化と宣言が近くなることからこのスタイルを勧めます。
その部分だけを切り出して書けるのでこのような形がよいと思います。

```c++
int n, m;
cin >> n >> m;

string s;
cin >> s;

vector<int> v(m);
for (auto i = 0; i < n; i++) {
  int tmp;
  cin >> tmp;
  v[tmp % m]++;
}
```

のような雰囲気でお願いします。

### 変数のスコープは小さくする

```c++
int i, j;
for (i = 0, j = 0; i + j < n; i++, j += 2) { /* ... */ }
// 以降で i, j を用いていない
```

よりも

```c++
for (int i = 0, j = 0; i + j < n; i++, j += 2) { /* ... */ }
```

のようにかけるならそのようにしてください。

### 省略しすぎない命名をする

`comb` を見ても combination より先に『櫛』に見えたりします (見えました)。
また, `check` なども意味が取りにくいです.
基本的に「模範解答」として読みやすい命名をしたいところです。

きっちり書く

<!--
`dp` としない
-->

### 変数、関数は基本的に lower_snake_case で命名する

もし **問題文で N, M となっていても**

```c++
int n, m;
cin >> n >> m;
```

のように書いてください。

### constexpr 定数は CONSTANT_CASE で宣言する

どちらでもよいです

### クラス、構造体、union は PascalCase で命名する

<!--正直言うと STL/boost に合わせて snake_case の方が収まりが良いのですが、世の中の慣習としてクラス等は PascalCase で命名する場合がかなり多いです (snake_case を命名の基本としている ruby や rust でもそうです)。

クラス問題集などの場面で他の言語と並べたときに浮く、というようなことがあるなら PascalCase で良いと思います。

例えば特殊なデータ構造（UnionFind とかセグ木とか？）等を実装したいのであれば、`onordered_map` のような STL のものと合わせる意味も込めて `segment_tree` のような形式の方が馴染むかと思われます。

(こう考えると snake_case ではデータ構造的な意味合いが強くなるのかもしれません)
-->

### enum 型名は lower_snake_case / 中身は CONSTANT_CASE にする (一旦)

### テンプレート型引数、非型テンプレート引数

基本的に `T`, `S` とか

必要ならば `PascalCase`

### 桁区切りできるならする

```c++
1'000'000'009 // ok
1000000009 // 分かりにくい
```

### typedef は using にする

古いので。

```c++
typedef long long ll; // bad
using ll = long long; // good
```

型エイリアスではテンプレート化もできますし、

```c++
typedef int (*f)(double, string);  // bad
using f = int (*)(double, string); // good
```

みたいなものでも分かりやすさが違います。

### range-based for、auto 宣言、構造化束縛などは積極的に用いる

せっかく c++ なので用いない手はないです。
paiza の clang++ は c++17 なのでそこまで利用できるものならば活用しましょう。

```c++
for (const auto [x, y] : points) { /*...*/ }
```

のように書けるとよいです。

### auto ... -> ret_type で関数を定義するのは避ける

```c++
int main() { return 0; } // good
auto main() -> int { return 0; } // bad
```

基本的には全く意味がないので避ける

ただしテンプレートで decltype で云々ならまあ後置でよいかもしれません。

<!--
### 関数の引数は 5 個を最大とする

```c++
using point = std::pair<int, int>;
int solve(point start, point goal, point via);
```

多すぎると追うのが大変です。ひとまとまりのものは構造体（こちらを推奨：アクセス時に識別子を分かりやすいものにできるため）や pair などにするとよいかもしれません。
-->

### 関数の引数を書き換える (out 的なパターン) は避ける

c だとエラーの仕組みがないので戻り値でエラー判定なんてこともしていますが、このパターンは基本的に避けてください。

基本的には関数の戻り値を利用し、破壊的なものならばクラスのメソッドとして実装するのが丸いと思われます。

```c++

```

### ラムダ関数式は型を後置で宣言する

### ネストが深くならないように気をつける (早期 return などを使う)

### c 形式のキャストはしない

使うなら関数形式、または名前付きキャストにしてください。

```c++
auto i = (int) d; // bad
auto i = int(d);  // good
auto i = static_cast<int>(d); // best (maybe)
```

### 真偽値には int ではなく bool を用いる (まあ正直どっちでもいい気もするけど)

```c++
while (1)    // うーん
while (true) // ok
```

### 偶奇判定に &1 をつかわない

剰余をとるという話であれば, すなおに `%` しましょう

```c++
if (i % 2 != 0) // good
if (i & 1) // ?
```

### データはまとめる (めんどくさくない程度に)

座標を `x`, `y` のようにバラして扱うより, `pair` や `tuple` のように意味のあるかたまりとして纏めることを推奨します.

三次元座標であれば `tuple<int, int, int>` のようにして扱うことができます.

### if や while のブロックの波括弧は毎回書く (考えるのが面倒なので)